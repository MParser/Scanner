# WebSocket客户端消息处理流程

```mermaid
flowchart TD
    A[客户端发送请求] -->|send_request| B[创建Future对象]
    B --> C[发送JSON请求消息]
    C --> D[等待响应]

    E[消息处理循环] -->|接收消息| F{消息类型?}
    
    F -->|二进制数据| G{是否有文件请求?}
    G -->|是| H[追加到文件块]
    G -->|否| E
    
    F -->|JSON消息| I{消息type?}
    
    I -->|check| J[忽略心跳包]
    J --> E
    
    I -->|file| K{data类型?}
    K -->|start| L[初始化文件接收]
    K -->|end| M[等待response]
    L --> E
    M --> E
    
    I -->|response| N{是否有request_id?}
    N -->|否| E
    N -->|是| O{code是否200?}
    
    O -->|是| P{是否文件请求?}
    P -->|是| Q[合并文件数据]
    Q --> R[设置Future结果]
    P -->|否| R
    
    O -->|否| S[清理文件数据]
    S --> T[设置Future异常]
    
    R --> E
    T --> E
    
    subgraph 错误处理
        U[连接断开] -->|重连机制| V{重连次数<最大值?}
        V -->|是| W[等待重连间隔]
        W --> X[重新连接]
        V -->|否| Y[停止重连]
        
        Z[请求超时] --> AA[清理请求状态]
        AA --> AB[抛出超时异常]
    end
```

## 流程说明

### 1. 请求发送流程
- 创建Future对象等待响应
- 发送JSON格式的请求消息
- 等待响应或超时

### 2. 消息处理流程
- 二进制数据：直接追加到文件块（如果有文件请求）
- JSON消息根据type分类处理：
  - `check`：直接忽略
  - `file`：处理文件传输的开始和结束
  - `response`：处理响应结果

### 3. 文件传输流程
- start -> 初始化文件接收
- 接收字节数据 -> 追加到文件块
- end -> 等待最终response
- response -> 合并文件数据到响应中

### 4. 错误处理流程
- 连接断开：尝试重连
- 请求超时：清理状态并抛出异常
- 错误响应：清理文件数据并设置异常

## 关键特点
1. 所有消息处理都在一个循环中进行
2. 文件传输和普通请求使用相同的基础机制
3. 错误处理贯穿整个流程
4. 心跳包被直接忽略，不影响主要流程
